<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Digibike Royale</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#000;font-family:'Share Tech Mono',monospace;}
canvas{display:block;width:100%;height:100%;}
/* Menu */
#menu{
  position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:rgba(0,0,0,0.85);z-index:20;color:#fff;
}
#title{
  font-size:92px;color:cyan;margin-bottom:20px;font-weight:bold;animation:bob 1.5s infinite alternate;
  text-shadow:0 0 15px cyan,0 0 30px cyan;
}
@keyframes bob{0%{transform:translateY(0);}100%{transform:translateY(20px);}}
#menu input,#menu select,#menu button{
  margin:8px;padding:12px 16px;font-size:18px;background:#111;border:2px solid cyan;color:#fff;border-radius:8px;
  text-shadow:0 0 5px cyan;cursor:pointer;transition:all .18s ease;
}
#menu input:focus,#menu select:focus,#menu button:hover{border-color:#0ff;box-shadow:0 0 14px rgba(0,255,255,.12);outline:none;}
#instructions{display:none;margin-top:12px;background:rgba(0,0,0,0.9);padding:12px;border-radius:8px;text-align:left;max-width:420px;}
/* HUD */
#hud{position:absolute;top:10px;left:10px;color:white;font-weight:bold;font-size:20px;z-index:15;pointer-events:none;}
/* Spectate */
#spectateMenu{
  position: absolute; left:50%; transform:translateX(-50%); bottom:8%; background:rgba(0,0,0,0.85);
  padding:18px;border-radius:10px;color:white;display:none;z-index:30;text-align:center;
}
#spectateMenu button{padding:10px 14px;margin-top:8px;background:#111;border:2px solid cyan;color:white;border-radius:8px;cursor:pointer;}
#spectateMenu button:hover{border-color:#0ff}
</style>
</head>
<body>
<div id="menu">
  <div id="title">Digibike Royale</div>
  <input id="playerName" placeholder="Enter your name" maxlength="12" />
  <select id="bikeColor">
    <option value="cyan">Cyan</option>
    <option value="magenta">Magenta</option>
    <option value="yellow">Yellow</option>
    <option value="lime">Lime</option>
    <option value="blue">Blue</option>
    <option value="red">Red</option>
    <option value="green">Green</option>
  </select>
  <button id="startBtn">Let's race!</button>
  <button id="showInstructions">Controls & Instructions</button>
  <div id="instructions">
    <p>WASD — Move</p>
    <p>Space — Throw light disc (requires ammo)</p>
    <p>Shift — Pause (hold)</p>
    <p>M — Expand mini-map while held</p>
    <p>Collect white discs for ammo. Self-touch allowed for 2 steps as grace — after that it kills you.</p>
  </div>
</div>

<div id="spectateMenu">
  <h3 id="specText">Spectating...</h3>
  <button id="backToMenu">Back to Main Menu</button>
</div>

<div id="hud"></div>
<canvas id="gameCanvas"></canvas>

<script>
/* ---------- Setup & Globals ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

const hud = document.getElementById('hud');
const spectateMenu = document.getElementById('spectateMenu');
const menu = document.getElementById('menu');
const titleEl = document.getElementById('title');

let gameRunning = false;
let paused = false;
let miniMapExpanded = false;

const PLAYER_SPEED = 2.2;     // 10% faster
const BOT_COUNT = 15;
const TRAIL_LENGTH = 50;
const DISC_COUNT = 10;

let storm = { x:0, y:0, w:width, h:height,
  shrinkTimer:0, shrinkCooldown:30000, shrinkDuration:5000,
  moving:false, startX:0, startY:0, endX:0, endY:0, moveProgress:0
};

let camera = { x:0, y:0 };

const tronNames = ["BitCrusher","LightSpinner","GridGhost","NeonKnight","SparkWraith","ByteRider","PhotonPunk","LaserLad","Glowtron","CircuitCreeper","FlashFury","DataDash","TurboByte","PixelPhantom","ZapZebra","NeonNarwhal","QuantumQuill","ElectroElf","VaporViper","GlitchGoblin"];
const bikeColors = ["cyan","magenta","yellow","lime","blue","red","green"];

let player = null;
let bots = [];
let discs = [];
let projectiles = [];
let particles = [];
let spectating = null;

/* ---------- Helpers ---------- */
function hexToRgb(color){
  const colors = { cyan:'0,255,255', magenta:'255,0,255', yellow:'255,255,0', lime:'0,255,0', blue:'0,0,255', red:'255,0,0', green:'0,128,0' };
  return colors[color] || '255,255,255';
}

/* ---------- Classes ---------- */
class Bike {
  constructor(x,y,color,name,isBot=false){
    this.x = x; this.y = y;
    this.color = color;            // original color
    this.trailColor = color;       // fixed trail color for drawing
    this.name = name; this.isBot = isBot;
    this.dir = 'right';
    this.trail = [];               // points: {x,y,bike}
    this.alive = true; this.ammo = 0;
    this.trailGrace = 2;           // allow stepping on own trail safely this many times
    this.decisionTimer = Math.random()*1000+500; this.lastDecision = 0; this.target = null; this.killer = null;
  }
  move(delta){
    if(!this.alive) return;
    if(this.isBot) this.aiMove(delta);
    // move with configured speed
    let speed = PLAYER_SPEED;
    if(this.dir === 'up') this.y -= speed;
    if(this.dir === 'down') this.y += speed;
    if(this.dir === 'left') this.x -= speed;
    if(this.dir === 'right') this.x += speed;
    // push trail point that owns this bike
    this.trail.push({ x:this.x, y:this.y, bike:this });
    if(this.trail.length > TRAIL_LENGTH) this.trail.shift();
  }
  aiMove(delta){
    if(!player) return;
    this.lastDecision += delta;
    if(!this.target || !this.target.alive){
      let possible = [player, ...bots.filter(b=>b!==this && b.alive)];
      if(possible.length>0) this.target = possible[Math.floor(Math.random()*possible.length)];
    }
    if(this.lastDecision > this.decisionTimer){
      this.lastDecision = 0;
      this.decisionTimer = 200 + Math.random()*400; // more reactive
      if(!this.target) return;

      // Predict target a bit ahead
      let futureX = this.target.x + (this.target.dir === 'right' ? 20 : this.target.dir === 'left' ? -20 : 0);
      let futureY = this.target.y + (this.target.dir === 'down' ? 20 : this.target.dir === 'up' ? -20 : 0);
      let dx = futureX - this.x, dy = futureY - this.y;

      let preferred = (Math.abs(dx) > Math.abs(dy)) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');

      // Evaluate candidate directions
      let candidates = [preferred, 'up','down','left','right'].filter((v,i)=>v);
      // remove duplicates preserving order
      candidates = [...new Set(candidates)];

      // choose first safe candidate
      let chosen = null;
      for(let d of candidates){
        let nx = this.x + (d === 'left' ? -PLAYER_SPEED : d === 'right' ? PLAYER_SPEED : 0);
        let ny = this.y + (d === 'up' ? -PLAYER_SPEED : d === 'down' ? PLAYER_SPEED : 0);

        if(nx < storm.x || nx > storm.x + storm.w || ny < storm.y || ny > storm.y + storm.h) continue;

        let danger = false;
        // trails
        [player, ...bots].forEach(b=>{
          if(!b) return;
          for(let t of b.trail){
            if(Math.abs(nx - t.x) < 10 && Math.abs(ny - t.y) < 10) { danger = true; break; }
          }
        });
        if(danger) continue;
        // projectiles
        for(let p of projectiles){
          if(Math.abs(nx - p.x) < 15 && Math.abs(ny - p.y) < 15){ danger = true; break; }
        }
        if(danger) continue;

        // clustering avoid: don't pick directions that land very near other bikes
        let near = false;
        for(let b of [player,...bots]){
          if(!b || b === this) continue;
          if(Math.abs(nx - b.x) < 24 && Math.abs(ny - b.y) < 24){ near = true; break; }
        }
        if(near) continue;

        chosen = d; break;
      }

      if(chosen) this.dir = chosen;
      else {
        // emergency random safe direction inside storm box
        const allDirs = ['up','down','left','right'];
        let safe = allDirs.filter(d=>{
          let nx = this.x + (d === 'left' ? -PLAYER_SPEED : d === 'right' ? PLAYER_SPEED : 0);
          let ny = this.y + (d === 'up' ? -PLAYER_SPEED : d === 'down' ? PLAYER_SPEED : 0);
          return nx >= storm.x && nx <= storm.x + storm.w && ny >= storm.y && ny <= storm.y + storm.h;
        });
        if(safe.length>0) this.dir = safe[Math.floor(Math.random()*safe.length)];
      }
    }
  }
  draw(){
    if(!this.alive) return;
    // trail
    ctx.shadowBlur = 12; ctx.shadowColor = this.trailColor;
    for(let t of this.trail){
      ctx.fillStyle = this.trailColor;
      ctx.fillRect(t.x - camera.x - 2, t.y - camera.y - 2, 4, 4);
    }
    ctx.shadowBlur = 0;
    // bike
    ctx.fillStyle = this.trailColor;
    ctx.fillRect(this.x - camera.x - 5, this.y - camera.y - 5, 10, 10);
    // name
    ctx.fillStyle = 'white'; ctx.font = '16px Share Tech Mono';
    const textW = ctx.measureText(this.name).width;
    ctx.fillText(this.name, this.x - camera.x - textW/2, this.y - camera.y - 10);
  }
}

class Disc {
  constructor(){ this.x = Math.random()*width; this.y = Math.random()*height; this.radius = 8; }
  draw(){ ctx.shadowBlur = 10; ctx.shadowColor = 'white'; ctx.beginPath(); ctx.arc(this.x - camera.x, this.y - camera.y, this.radius, 0, Math.PI*2); ctx.fillStyle='white'; ctx.fill(); ctx.shadowBlur=0; }
}

class Projectile {
  constructor(x,y,dir,color){ this.x=x; this.y=y; this.dir=dir; this.color=color; this.alive=true; this.speed=5; }
  update(){
    if(this.dir==='up') this.y -= this.speed;
    if(this.dir==='down') this.y += this.speed;
    if(this.dir==='left') this.x -= this.speed;
    if(this.dir==='right') this.x += this.speed;
    if(this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.alive = false;
  }
  draw(){
    ctx.shadowBlur = 12; ctx.shadowColor = this.color;
    ctx.beginPath(); ctx.arc(this.x - camera.x, this.y - camera.y, 5, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill(); ctx.shadowBlur = 0;
  }
}

/* ---------- Input ---------- */
const keys = { w:false, a:false, s:false, d:false, shift:false, space:false, m:false };
document.addEventListener('keydown', e => {
  if(e.key === 'w') keys.w = true;
  if(e.key === 'a') keys.a = true;
  if(e.key === 's') keys.s = true;
  if(e.key === 'd') keys.d = true;
  if(e.key === 'Shift') keys.shift = true;
  if(e.key === ' ') keys.space = true;
  if(e.key === 'm') keys.m = true;
});
document.addEventListener('keyup', e => {
  if(e.key === 'w') keys.w = false;
  if(e.key === 'a') keys.a = false;
  if(e.key === 's') keys.s = false;
  if(e.key === 'd') keys.d = false;
  if(e.key === 'Shift') keys.shift = false;
  if(e.key === ' ') keys.space = false;
  if(e.key === 'm') keys.m = false;
});

/* ---------- UI wiring ---------- */
const startBtn = document.getElementById('startBtn');
const showInstructions = document.getElementById('showInstructions');
const instructions = document.getElementById('instructions');
const backToMenu = document.getElementById('backToMenu');
const bikeColorSelect = document.getElementById('bikeColor');

startBtn.addEventListener('click', ()=>{
  const name = document.getElementById('playerName').value || 'Player';
  const color = bikeColorSelect.value || 'cyan';
  menu.style.display = 'none';
  startGame(name, color);
});

showInstructions.addEventListener('click', ()=> {
  instructions.style.display = instructions.style.display === 'none' ? 'block' : 'none';
});

backToMenu.addEventListener('click', ()=>{
  spectateMenu.style.display = 'none';
  menu.style.display = 'flex';
  gameRunning = false;
  spectating = null;
});

bikeColorSelect.addEventListener('change', ()=>{
  const c = bikeColorSelect.value;
  // menu tint
  menu.style.background = `rgba(${hexToRgb(c)},0.85)`;
  // style buttons
  [startBtn, showInstructions].forEach(btn=>{
    btn.style.background = c;
    btn.style.border = '2px solid white';
    btn.style.color = 'white';
    btn.style.boxShadow = `0 0 16px ${c}`;
  });
  titleEl.style.color = c;
  titleEl.style.textShadow = `0 0 20px ${c}, 0 0 40px ${c}`;
});

/* ---------- Game flow ---------- */
let lastTime = 0;
function startGame(playerName, bikeColor){
  gameRunning = true; spectating = null;
  player = new Bike(Math.random()*width, Math.random()*height, bikeColor, playerName, false);
  bots = []; discs = []; projectiles = []; particles = [];
  for(let i=0;i<BOT_COUNT;i++){
    let name = tronNames[Math.floor(Math.random()*tronNames.length)];
    let color = bikeColors[Math.floor(Math.random()*bikeColors.length)];
    bots.push(new Bike(Math.random()*width, Math.random()*height, color, name, true));
  }
  for(let i=0;i<DISC_COUNT;i++) discs.push(new Disc());
  storm = { x:0, y:0, w:width, h:height, shrinkTimer:0, shrinkCooldown:30000, shrinkDuration:5000, moving:false, startX:0, startY:0, endX:0, endY:0, moveProgress:0 };
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function loop(ts){
  if(!gameRunning) return;
  let delta = ts - lastTime; lastTime = ts;
  requestAnimationFrame(loop);
  // pause while holding shift (as you had)
  paused = keys.shift;
  if(paused) return;
  update(Math.min(delta, 60));
  draw();
}

/* ---------- Particles ---------- */
function createParticles(x,y,color){
  for(let i=0;i<40;i++){
    let angle = Math.random()*Math.PI*2;
    let speed = Math.random()*4 + 0.5;
    let vx = Math.cos(angle)*speed, vy = Math.sin(angle)*speed;
    let life = 30 + Math.floor(Math.random()*30);
    particles.push({ x,y,vx,vy,life,color });
  }
}
function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    let p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.96; p.vy *= 0.96;
    p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
}
function drawParticles(){
  for(let p of particles){
    let a = Math.max(p.life / 60, 0);
    ctx.fillStyle = `rgba(${hexToRgb(p.color)},${a})`;
    ctx.fillRect(p.x - camera.x, p.y - camera.y, 3, 3);
  }
}

/* ---------- UPDATE (full rewrite) ---------- */
function update(delta){
  miniMapExpanded = keys.m;

  // Player input -> direction
  if(player && player.alive){
    if(keys.w) player.dir = 'up';
    if(keys.s) player.dir = 'down';
    if(keys.a) player.dir = 'left';
    if(keys.d) player.dir = 'right';
  }

  // Move bikes
  if(player && player.alive) player.move(delta);
  for(let b of bots) b.move(delta);

  // Storm timing + movement + linear shrink
  storm.shrinkTimer += delta;
  if(storm.shrinkTimer > storm.shrinkCooldown){
    storm.shrinkTimer = 0;
    storm.startX = storm.x; storm.startY = storm.y;
    // choose a smaller rectangle inside current storm to move to
    let newW = Math.max(120, storm.w * 0.8);
    let newH = Math.max(120, storm.h * 0.8);
    storm.endX = storm.x + Math.random() * (storm.w - newW);
    storm.endY = storm.y + Math.random() * (storm.h - newH);
    storm.moving = true;
    storm.moveProgress = 0;
    storm.targetW = newW;
    storm.targetH = newH;
  }
  if(storm.moving){
    storm.moveProgress += delta / storm.shrinkDuration;
    if(storm.moveProgress >= 1){
      storm.moveProgress = 1; storm.moving = false;
      storm.x = storm.endX; storm.y = storm.endY; storm.w = storm.targetW; storm.h = storm.targetH;
    } else {
      // interpolate position
      storm.x = storm.startX + (storm.endX - storm.startX) * storm.moveProgress;
      storm.y = storm.startY + (storm.endY - storm.startY) * storm.moveProgress;
      // interpolate size
      storm.w = (storm.w * (1 - storm.moveProgress)) + (storm.targetW * storm.moveProgress);
      storm.h = (storm.h * (1 - storm.moveProgress)) + (storm.targetH * storm.moveProgress);
    }
  }

  // Disc pickups
  for(let i = discs.length - 1; i >= 0; i--){
    let d = discs[i];
    for(let b of [player, ...bots]){
      if(!b || !b.alive) continue;
      let dx = b.x - d.x, dy = b.y - d.y;
      if(Math.hypot(dx,dy) < 15){
        b.ammo++;
        discs.splice(i,1);
        discs.push(new Disc());
        break;
      }
    }
  }

  // Shooting - player
  if(keys.space && player && player.alive && player.ammo > 0){
    projectiles.push(new Projectile(
      player.x + (player.dir==='right' ? 10 : player.dir==='left' ? -10 : 0),
      player.y + (player.dir==='down' ? 10 : player.dir==='up' ? -10 : 0),
      player.dir, player.color
    ));
    player.ammo--;
  }
  // Bots shooting (random)
  for(let b of bots){
    if(!b.alive) continue;
    if(b.ammo > 0 && Math.random() < 0.007){
      projectiles.push(new Projectile(
        b.x + (b.dir==='right' ? 10 : b.dir==='left' ? -10 : 0),
        b.y + (b.dir==='down' ? 10 : b.dir==='up' ? -10 : 0),
        b.dir, b.color
      ));
      b.ammo--;
    }
  }

  // Build allTrails once (flat array of points)
  let allTrails = [];
  for(let b of bots) if(b) allTrails.push(...b.trail);
  if(player) allTrails.push(...player.trail);

  // Projectiles update & collisions (projectile vs trail -> kill trail owner)
  for(let i = projectiles.length - 1; i >= 0; i--){
    let p = projectiles[i];
    p.update();
    if(!p.alive){ projectiles.splice(i,1); continue; }

    // projectile vs bike (direct hit)
    let hitBike = null;
    for(let b of [player, ...bots]){
      if(!b || !b.alive) continue;
      if(Math.abs(b.x - p.x) < 10 && Math.abs(b.y - p.y) < 10 && b.color !== p.color){
        hitBike = b; break;
      }
    }
    if(hitBike){
      hitBike.alive = false;
      createParticles(hitBike.x, hitBike.y, hitBike.color);
      // find killer by projectile color (could be multiple same color; take nearest)
      let killer = [player, ...bots].filter(k => k && k.color === p.color)[0] || null;
      if(killer){
        killer.trail = killer.trail.concat(hitBike.trail.map(tt=>({ x:tt.x, y:tt.y, bike:killer })));
      }
      hitBike.killer = killer;
      if(hitBike === player) startSpectating(killer);
      projectiles.splice(i,1);
      continue;
    }

    // projectile vs trail (hit trail point) - kill owner of trail point
    let hitTrailPoint = null;
    for(let t of allTrails){
      if(Math.abs(p.x - t.x) < 6 && Math.abs(p.y - t.y) < 6){
        hitTrailPoint = t; break;
      }
    }
    if(hitTrailPoint){
      let target = hitTrailPoint.bike;
      if(target && target.alive){
        target.alive = false;
        createParticles(target.x, target.y, target.color);
        // killer detection: projectile color owner or nearest of that color
        let killer = [player, ...bots].filter(k => k && k.color === p.color)[0] || null;
        if(killer){
          killer.trail = killer.trail.concat(target.trail.map(tt=>({ x:tt.x, y:tt.y, bike:killer })));
        }
        target.killer = killer;
        if(target === player) startSpectating(killer);
      }
      projectiles.splice(i,1);
      continue;
    }
  }

  // Bike vs trail & storm collisions
  for(let b of [player, ...bots]){
    if(!b || !b.alive) continue;
    // check trails (including own trail but allow grace for own)
    for(let t of allTrails){
      // if this exact trail point belongs to this bike and it's among its own current trail, then treat as possible self-hit subject to grace
      if(t.bike === b){
        // if very recent (last few moves) allow grace
        if(b.trailGrace > 0){
          // decrease only when the bike actually steps onto its own trail point (matching position)
          if(Math.abs(b.x - t.x) < 5 && Math.abs(b.y - t.y) < 5){
            b.trailGrace--;
            // ignore this collision
            continue;
          } else {
            // not standing on this own trail point; nothing to do
            continue;
          }
        }
        // if no grace left we should still test normally; fall through
      }
      // skip comparing to an exact same trail point that is part of the bike's current trail array (because bikes push their own trail each frame) — but now we intentionally do not skip so collisions with own trail are possible after grace
      if(Math.abs(b.x - t.x) < 5 && Math.abs(b.y - t.y) < 5){
        // Determine killer as the bike owning that trail point
        let killer = t.bike;
        b.alive = false;
        createParticles(b.x, b.y, b.color);
        if(killer && killer.alive){
          killer.trail = killer.trail.concat(b.trail.map(tt => ({ x:tt.x, y:tt.y, bike:killer })));
        }
        b.killer = killer;
        if(b === player) startSpectating(killer);
        break;
      }
    }

    // Storm boundary
    if(b.alive && (b.x < storm.x || b.x > storm.x + storm.w || b.y < storm.y || b.y > storm.y + storm.h)){
      b.alive = false;
      createParticles(b.x, b.y, b.color);
      let aliveKiller = [player, ...bots].find(bb => bb && bb.alive);
      if(aliveKiller){
        aliveKiller.trail = aliveKiller.trail.concat(b.trail.map(tt => ({ x:tt.x, y:tt.y, bike:aliveKiller })));
      }
      b.killer = aliveKiller;
      if(b === player) startSpectating(aliveKiller);
    }
  }

  // update particles
  updateParticles();

  // camera follow (POV follow player or spectating)
  camera.x = ((spectating ? spectating.x : (player ? player.x : width/2)) || 0) - width/2;
  camera.y = ((spectating ? spectating.y : (player ? player.y : height/2)) || 0) - height/2;

  // win/finish condition
  let aliveList = [player, ...bots].filter(b => b && b.alive);
  if(aliveList.length <= 1){
    gameRunning = false;
    spectating = null;
    setTimeout(()=> { menu.style.display = 'flex'; }, 900);
  }
}

/* ---------- DRAW ---------- */
function draw(){
  // clear full canvas
  ctx.clearRect(0,0,width,height);

  // draw storm/warning: fill red everywhere then clear storm area to show safe zone
  ctx.fillStyle = 'rgba(200,20,20,0.95)'; // red
  ctx.fillRect(0,0,width,height);

  // clear safe area (storm rectangle)
  ctx.clearRect(storm.x - camera.x, storm.y - camera.y, storm.w, storm.h);

  // optional halo/border for storm
  ctx.lineWidth = 4;
  ctx.strokeStyle = 'rgba(180,20,20,0.9)';
  ctx.strokeRect(storm.x - camera.x, storm.y - camera.y, storm.w, storm.h);

  // draw discs
  for(let d of discs) d.draw();

  // draw bikes and trails
  if(player) player.draw();
  for(let b of bots) b.draw();

  // draw projectiles
  for(let p of projectiles) p.draw();

  // particles
  drawParticles();

  // HUD
  const aliveCount = [player, ...bots].filter(b=>b && b.alive).length;
  hud.innerHTML = `Players: ${aliveCount}<br>Ammo: ${player && player.alive ? player.ammo : 0}`;

  // minimap
  const mapSize = miniMapExpanded ? 200 : 100;
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(10,10,mapSize,mapSize);
  // storm on minimap
  ctx.strokeStyle = 'red';
  ctx.strokeRect(storm.x/width*mapSize+10, storm.y/height*mapSize+10, storm.w/width*mapSize, storm.h/height*mapSize);
  for(let b of [player, ...bots]){
    if(!b || !b.alive) continue;
    ctx.fillStyle = b.trailColor;
    ctx.fillRect(b.x/width*mapSize+10, b.y/height*mapSize+10, 4, 4);
  }
}

/* ---------- Spectating ---------- */
function startSpectating(bike){
  spectating = bike;
  if(!bike) {
    spectateMenu.style.display = 'none';
    return;
  }
  spectateMenu.style.display = 'block';
  document.getElementById('specText').textContent = `Spectating ${bike.name}`;
}

/* ---------- Resize ---------- */
window.addEventListener('resize', ()=>{
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});

/* ---------- Initial state (menu visible) ---------- */
menu.style.display = 'flex';
titleEl.style.fontFamily = "'Share Tech Mono', monospace";

/* ---------- End of file ---------- */
</script>
</body>
</html>
